{
    "summary": "The code collects and processes results from various AI methods, storing them in dictionaries for analysis or visualization. It generates boxplots to display the final scores of different methods with customizable y-axis settings and font size. The code also sets labels, plots a bar graph, adds annotations, adjustments, and text, saves as PDF, replaces characters in model names, and calls another function.",
    "details": [
        {
            "comment": "This code retrieves complete results from a given base directory. It iterates through each folder in the directory, loads JSON files within each folder, and stores the key-value pairs as dictionaries within lists under each folder's name in a results dictionary. The code also checks if directories are not empty folders.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/set_intersection/plot.py\":0-28",
            "content": "# Copyright (c) 2023 ETH Zurich.\n#                    All rights reserved.\n#\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n#\n# main author: Nils Blach\n# contributions: Robert Gerstenberger\nimport json\nimport os\nimport matplotlib.pyplot as plt\ndef get_complete_results(base_directory):\n    results_complete = {}\n    for folder_name in os.listdir(base_directory):\n        folder_path = os.path.join(base_directory, folder_name)\n        if os.path.isdir(folder_path):\n            results_complete[folder_name] = []\n            for file_name in os.listdir(folder_path):\n                if file_name.endswith(\".json\"):\n                    file_path = os.path.join(folder_path, file_name)\n                    with open(file_path, \"r\") as f:\n                        data = json.load(f)\n                        results_complete[folder_name].append(\n                            {\"key\": int(file_name.split(\".\")[0]), \"data\": data}\n                        )\n        for key in results_complete.keys():"
        },
        {
            "comment": "This code organizes and processes results from various AI methods, extracting scores, solved status, prompt/completion tokens, and cost for each method. It stores this information in a dictionary for further analysis or visualization.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/set_intersection/plot.py\":29-57",
            "content": "            results_complete[key] = sorted(\n                results_complete[key], key=lambda x: x[\"key\"]\n            )\n    return results_complete\ndef get_final_scores(results_complete):\n    scores = {}\n    for method in results_complete.keys():\n        scores[method] = []\n        for result in results_complete[method]:\n            score = 100\n            solved = False\n            cost = 1\n            prompt_tokens = 0\n            completion_tokens = 0\n            for op in result[\"data\"]:\n                if \"operation\" in op and op[\"operation\"] == \"ground_truth_evaluator\":\n                    try:\n                        score = min(op[\"scores\"])\n                        solved = any(op[\"problem_solved\"])\n                    except:\n                        continue\n                if \"cost\" in op:\n                    cost = op[\"cost\"]\n                    prompt_tokens = op[\"prompt_tokens\"]\n                    completion_tokens = op[\"completion_tokens\"]\n            scores[method].append(\n                [result[\"key\"], score, solved, prompt_tokens, completion_tokens, cost]"
        },
        {
            "comment": "The code retrieves final scores from complete results and organizes them into a dictionary for plotting. It then creates a new dictionary with scores, solved problems count, and costs for each method. This data is used to plot the results in a graph, considering options like method order, model, length, cost limits, and display settings.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/set_intersection/plot.py\":58-93",
            "content": "            )\n        scores[method] = sorted(scores[method], key=lambda x: x[0])\n    return scores\ndef get_plotting_data(base_directory):\n    results_complete = get_complete_results(base_directory)\n    scores = get_final_scores(results_complete)\n    results_plotting = {\n        method: {\n            \"scores\": [x[1] for x in scores[method]],\n            \"solved\": sum([1 for x in scores[method] if x[2]]),\n            \"costs\": [x[5] for x in scores[method]],\n        }\n        for method in scores.keys()\n    }\n    return results_plotting\ndef plot_results(\n    results,\n    methods_order=[\"io\", \"cot\", \"tot\", \"tot2\", \"got\"],\n    model=\"GPT-3.5\",\n    length=32,\n    y_lower=0,\n    cost_upper=0.0,\n    display_solved=True,\n    annotation_offset=0,\n    display_left_ylabel=False,\n    display_right_ylabel=False,\n):\n    methods_order = [method for method in methods_order if method in results]\n    # Extract scores based on the order\n    scores_ordered = [\n        [score for score in results[method][\"scores\"] if score != 1000]\n        for method in methods_order"
        },
        {
            "comment": "This code creates a boxplot to visualize the results of different methods. It sets the y-axis limits and ticks based on the length of the data, and customizes the font size for better readability. The code also handles the display of additional information (solved count) by adjusting the range of y-axis ticks accordingly.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/set_intersection/plot.py\":94-129",
            "content": "    ]\n    total_costs = [sum(results[method][\"costs\"]) for method in methods_order]\n    # Create figure and axis\n    fig, ax = plt.subplots(dpi=150, figsize=(2.5, 5))\n    # Create boxplots\n    positions = range(1, len(methods_order) + 1)\n    ax.boxplot(scores_ordered, positions=positions)\n    fig_fontsize = 12\n    # Set the ticks and labels\n    methods_labels = [\"IO\", \"CoT\", \"ToT\", \"ToT2\", \"GoT\"]\n    plt.yticks(fontsize=fig_fontsize)\n    ax.set_xticks(range(1, len(methods_order) + 1))\n    ax.set_xticks(range(1, len(methods_order) + 1))\n    ax.set_xticklabels(methods_labels, fontsize=fig_fontsize)\n    y_upper = length\n    range_increase = 1\n    if display_solved:\n        if length < 48:\n            range_increase = 2\n        elif length < 96:\n            range_increase = 4\n        else:\n            range_increase = 8\n    ax.set_ylim(y_lower, y_upper + range_increase)\n    ax1_yticks = range(\n        y_lower, y_upper + 1, 2 if length < 48 else (4 if length < 96 else 8)\n    )\n    ax.set_yticks(ax1_yticks)\n    if display_left_ylabel:"
        },
        {
            "comment": "This code sets y-axis label, title, and twin axis for plotting. It then plots a bar graph using the twin axis, setting the y-axis limits and ticks based on specified conditions. Finally, it checks if certain conditions are met and adds annotations or adjusts the graph accordingly.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/set_intersection/plot.py\":130-161",
            "content": "        ax.set_ylabel(\n            f\"#incorrect elements; the lower the better\", fontsize=fig_fontsize\n        )\n    ax.set_title(f\"{length} elements\")\n    ax2 = ax.twinx()\n    ax2.bar(positions, total_costs, alpha=0.5, color=\"blue\", label=\"Total Cost ($)\")\n    ax2.yaxis.set_tick_params(colors=\"#1919ff\", labelsize=fig_fontsize)\n    if cost_upper > 0:\n        ax2.set_ylim(0, cost_upper)\n        number_of_ticks = len(ax.get_yticks())\n        tick_interval = cost_upper / (number_of_ticks)\n        ax2_ticks = [tick_interval * i for i in range(number_of_ticks)]\n        # Set custom tick positions for ax2\n        ax2.set_yticks(ax2_ticks)\n    if display_right_ylabel:\n        ax2.set_ylabel(\n            \"Total Cost ($); the lower the better\",\n            color=\"#1919ff\",\n            fontsize=fig_fontsize,\n        )\n    if display_solved:\n        annotation_height = y_upper + annotation_offset\n        count = 1\n        for method in methods_order:\n            if method not in results:\n                continue\n            solved = results[method][\"solved\"]"
        },
        {
            "comment": "This code is adding text annotations to a plot, incrementing a count variable, and saving the final plot as a PDF. It replaces certain characters in the model name and calls another function for more plotting results with specific parameters.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/set_intersection/plot.py\":162-183",
            "content": "            ax.text(\n                count,\n                annotation_height,\n                f\"{solved}\",\n                ha=\"center\",\n                va=\"bottom\",\n                fontsize=fig_fontsize,\n            )\n            count += 1\n    model = model.replace(\".\", \"\").replace(\"-\", \"\").lower()\n    fig.savefig(f\"set_intersection_{model}_{length}.pdf\", bbox_inches=\"tight\")\nplot_results(\n    get_plotting_data(\"results/\"),\n    length=32,\n    display_solved=True,\n    model=\"GPT-3.5\",\n    display_left_ylabel=True,\n    display_right_ylabel=True,\n)"
        }
    ]
}