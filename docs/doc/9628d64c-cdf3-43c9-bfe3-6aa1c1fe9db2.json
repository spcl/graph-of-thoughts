{
    "summary": "This code retrieves JSON data, organizes it in a dictionary and plots results using boxplots and bar charts with customizable titles. It also sets y-axis limits, handles missing results and displays solved values.",
    "details": [
        {
            "comment": "This code retrieves complete results from a given base directory, iterating through each folder and file. It collects JSON data from specified .json files, stores them in the \"results_complete\" dictionary with corresponding key and appends the data to its value.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/keyword_counting/plot.py\":0-28",
            "content": "# Copyright (c) 2023 ETH Zurich.\n#                    All rights reserved.\n#\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n#\n# main author: Nils Blach\n# contributions: Ales Kubicek\nimport json\nimport os\nimport matplotlib.pyplot as plt\ndef get_complete_results(base_directory):\n    results_complete = {}\n    for folder_name in os.listdir(base_directory):\n        folder_path = os.path.join(base_directory, folder_name)\n        if os.path.isdir(folder_path):\n            results_complete[folder_name] = []\n            for file_name in os.listdir(folder_path):\n                if file_name.endswith(\".json\"):\n                    file_path = os.path.join(folder_path, file_name)\n                    with open(file_path, \"r\") as f:\n                        data = json.load(f)\n                        results_complete[folder_name].append(\n                            {\"key\": int(file_name.split(\".\")[0]), \"data\": data}\n                        )\n        for key in results_complete.keys():"
        },
        {
            "comment": "The code sorts the results dictionary by key, then retrieves final scores for each method in the results_complete dictionary. It appends a list of scores (including score, solved status, prompt tokens, completion tokens, and cost) to the corresponding method in the scores dictionary.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/keyword_counting/plot.py\":29-57",
            "content": "            results_complete[key] = sorted(\n                results_complete[key], key=lambda x: x[\"key\"]\n            )\n    return results_complete\ndef get_final_scores(results_complete):\n    scores = {}\n    for method in results_complete.keys():\n        scores[method] = []\n        for result in results_complete[method]:\n            score = 100\n            solved = False\n            cost = 1\n            prompt_tokens = 0\n            completion_tokens = 0\n            for op in result[\"data\"]:\n                if \"operation\" in op and op[\"operation\"] == \"ground_truth_evaluator\":\n                    try:\n                        score = min(op[\"scores\"])\n                        solved = any(op[\"problem_solved\"])\n                    except:\n                        continue\n                if \"cost\" in op:\n                    cost = op[\"cost\"]\n                    prompt_tokens = op[\"prompt_tokens\"]\n                    completion_tokens = op[\"completion_tokens\"]\n            scores[method].append(\n                [result[\"key\"], score, solved, prompt_tokens, completion_tokens, cost]"
        },
        {
            "comment": "This code retrieves and prepares data for plotting keyword counting results. It first gets complete results from a specified base directory, then extracts final scores. The data is then organized into a dictionary format for plotting. The function `plot_results` takes this data, along with optional parameters to adjust the visualization. The code filters out irrelevant scores and orders them based on the input order.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/keyword_counting/plot.py\":58-92",
            "content": "            )\n        scores[method] = sorted(scores[method], key=lambda x: x[0])\n    return scores\ndef get_plotting_data(base_directory):\n    results_complete = get_complete_results(base_directory)\n    scores = get_final_scores(results_complete)\n    results_plotting = {\n        method: {\n            \"scores\": [x[1] for x in scores[method]],\n            \"solved\": sum([1 for x in scores[method] if x[2]]),\n            \"costs\": [x[5] for x in scores[method]],\n        }\n        for method in scores.keys()\n    }\n    return results_plotting\ndef plot_results(\n    results,\n    methods_order=[\"io\", \"cot\", \"tot\", \"tot2\", \"got4\", \"got8\", \"gotx\"],\n    model=\"GPT-3.5\",\n    y_lower=0,\n    y_upper=40,\n    cost_upper=1.8,\n    display_solved=True,\n    annotation_offset=1,\n    display_left_ylabel=False,\n    display_right_ylabel=False,\n):\n    methods_order = [method for method in methods_order if method in results]\n    # Extract scores based on the order\n    scores_ordered = [\n        [score for score in results[method][\"scores\"] if score != 100 and score != 300]"
        },
        {
            "comment": "This code generates a boxplot of keyword counting results and adds a bar chart of total costs to the same axes. It uses the matplotlib library for plotting, sets tick and label positions, and allows for customization of y-axis labels and title. The total costs are calculated by summing the \"costs\" values from the \"results\" dictionary for each method in a specified order.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/keyword_counting/plot.py\":93-121",
            "content": "        for method in methods_order\n    ]\n    total_costs = [sum(results[method][\"costs\"]) for method in methods_order]\n    # Create figure and axis\n    fig, ax = plt.subplots(dpi=150, figsize=(3.75, 4))\n    # Create boxplots\n    positions = range(1, len(methods_order) + 1)\n    ax.boxplot(scores_ordered, positions=positions)\n    fig_fontsize = 12\n    # Set the ticks and labels\n    methods_labels = [\"IO\", \"CoT\", \"ToT\", \"ToT2\", \"GoT4\", \"GoT8\", \"GoTx\"]\n    ax.set_xticks(range(1, len(methods_order) + 1))\n    ax.set_xticks(range(1, len(methods_order) + 1))\n    ax.set_xticklabels(methods_labels, fontsize=10)\n    ax.set_ylim(y_lower, (y_upper + 2) if display_solved else y_upper + 1)\n    plt.yticks(fontsize=fig_fontsize)\n    if display_left_ylabel:\n        ax.set_ylabel(f\"Number of errors; the lower the better\", fontsize=fig_fontsize)\n    ax.set_title(f\"Keyword Counting\")\n    ax2 = ax.twinx()\n    ax2.bar(positions, total_costs, alpha=0.5, color=\"blue\", label=\"Total Cost ($)\")\n    ax2.yaxis.set_tick_params(colors=\"#1919ff\", labelsize=fig_fontsize)"
        },
        {
            "comment": "This code is setting the y-axis limits and ticks for a graph, adding annotations for solved solutions, labeling the y-axis, and saving the figure with a specific file name. It also handles missing results by continuing to the next method in case one is not available. The purpose of this code is likely related to plotting a graph that compares different methods or models based on their performance (cost) and whether they solved the problem or not.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/keyword_counting/plot.py\":122-157",
            "content": "    ax2.set_ylim(0, cost_upper)\n    number_of_ticks = len(ax.get_yticks())\n    tick_interval = cost_upper / (number_of_ticks)\n    ax2_ticks = [tick_interval * i for i in range(number_of_ticks)]\n    ax2.set_yticks(ax2_ticks)\n    if display_right_ylabel:\n        ax2.set_ylabel(\n            \"Total Cost ($); the lower the better\",\n            color=\"#1919ff\",\n            fontsize=fig_fontsize,\n        )\n    if display_solved:\n        annotation_height = y_upper + annotation_offset\n        count = 1\n        for method in methods_order:\n            if method not in results:\n                continue\n            solved = results[method][\"solved\"]\n            ax.text(\n                count,\n                annotation_height,\n                f\"{solved}\",\n                ha=\"center\",\n                va=\"bottom\",\n                fontsize=fig_fontsize,\n            )\n            count += 1\n    model = model.replace(\".\", \"\").replace(\"-\", \"\").lower()\n    fig.savefig(f\"keyword_counting_{model}.pdf\", bbox_inches=\"tight\")\nplot_results("
        },
        {
            "comment": "This code is calling a function named 'get_plotting_data' to retrieve data from the \"results/\" directory and generate a plot. The model used for this task is \"GPT-3.5\". The y-axis has an upper limit of 35, and the cost axis has an upper limit of 9. The function will display solved values on the plot and show left and right y-labels.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/keyword_counting/plot.py\":158-166",
            "content": "    get_plotting_data(\"results/\"),\n    display_solved=True,\n    annotation_offset=-0.3,\n    model=\"GPT-3.5\",\n    y_upper=35,\n    display_left_ylabel=True,\n    display_right_ylabel=True,\n    cost_upper=9,\n)"
        }
    ]
}