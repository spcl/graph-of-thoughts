{
    "summary": "The code reads and sorts JSON data, calculates scores for sorting algorithm performances, plots boxplots, customizes options, adjusts y-axis limits, adds annotations, saves as PDF, and calls function with GPT-3.5 parameters.",
    "details": [
        {
            "comment": "This code reads a directory of JSON files, extracts their key and data, and stores them in a dictionary. It handles directories recursively and does not include non-JSON files or folders without .json files. This function may be used to collect and organize data from multiple sources.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/sorting/plot.py\":0-28",
            "content": "# Copyright (c) 2023 ETH Zurich.\n#                    All rights reserved.\n#\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n#\n# main author: Nils Blach\n# contributions: Robert Gerstenberger\nimport json\nimport os\nimport matplotlib.pyplot as plt\ndef get_complete_results(base_directory):\n    results_complete = {}\n    for folder_name in os.listdir(base_directory):\n        folder_path = os.path.join(base_directory, folder_name)\n        if os.path.isdir(folder_path):\n            results_complete[folder_name] = []\n            for file_name in os.listdir(folder_path):\n                if file_name.endswith(\".json\"):\n                    file_path = os.path.join(folder_path, file_name)\n                    with open(file_path, \"r\") as f:\n                        data = json.load(f)\n                        results_complete[folder_name].append(\n                            {\"key\": int(file_name.split(\".\")[0]), \"data\": data}\n                        )\n        for key in results_complete.keys():"
        },
        {
            "comment": "Code sorts results by \"key\" and returns them in a new dictionary. The sorted results are then processed to calculate scores for each method, including score, solution status, prompt tokens, completion tokens, and cost.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/sorting/plot.py\":29-57",
            "content": "            results_complete[key] = sorted(\n                results_complete[key], key=lambda x: x[\"key\"]\n            )\n    return results_complete\ndef get_final_scores(results_complete):\n    scores = {}\n    for method in results_complete.keys():\n        scores[method] = []\n        for result in results_complete[method]:\n            score = 100\n            solved = False\n            cost = 1\n            prompt_tokens = 0\n            completion_tokens = 0\n            for op in result[\"data\"]:\n                if \"operation\" in op and op[\"operation\"] == \"ground_truth_evaluator\":\n                    try:\n                        score = min(op[\"scores\"])\n                        solved = any(op[\"problem_solved\"])\n                    except:\n                        continue\n                if \"cost\" in op:\n                    cost = op[\"cost\"]\n                    prompt_tokens = op[\"prompt_tokens\"]\n                    completion_tokens = op[\"completion_tokens\"]\n            scores[method].append(\n                [result[\"key\"], score, solved, prompt_tokens, completion_tokens, cost]"
        },
        {
            "comment": "The code defines a function `get_plotting_data` that extracts and organizes data for plotting. It takes the base directory as input, retrieves complete results from it, then gets final scores. The final scores are organized into a dictionary called `results_plotting`, which contains scores, solved counts, and costs for each method. Another function, `plot_results`, is defined to handle the actual plotting of the data with customizable options. It extracts scores in the specified order, organizes them, and provides customizability such as display settings and annotations.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/sorting/plot.py\":58-94",
            "content": "            )\n        scores[method] = sorted(scores[method], key=lambda x: x[0])\n    return scores\ndef get_plotting_data(base_directory):\n    results_complete = get_complete_results(base_directory)\n    scores = get_final_scores(results_complete)\n    results_plotting = {\n        method: {\n            \"scores\": [x[1] for x in scores[method]],\n            \"solved\": sum([1 for x in scores[method] if x[2]]),\n            \"costs\": [x[5] for x in scores[method]],\n        }\n        for method in scores.keys()\n    }\n    return results_plotting\ndef plot_results(\n    results,\n    methods_order=[\"io\", \"cot\", \"tot\", \"tot2\", \"got\"],\n    model=\"GPT-3.5\",\n    length=32,\n    y_lower=0,\n    cost_upper=0.0,\n    display_solved=True,\n    annotation_offset=0,\n    display_left_ylabel=False,\n    display_right_ylabel=False,\n):\n    methods_order = [method for method in methods_order if method in results]\n    # Extract scores based on the order\n    scores_ordered = [\n        [\n            min(score, length)\n            for score in results[method][\"scores\"]"
        },
        {
            "comment": "This code creates a boxplot to visualize the scores of different methods, sets the ticks and labels, adjusts the y-axis limits based on length, and defines the y-lower limit as y_lower.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/sorting/plot.py\":95-130",
            "content": "            if score != 100 and score != 300\n        ]\n        for method in methods_order\n    ]\n    total_costs = [sum(results[method][\"costs\"]) for method in methods_order]\n    # Create figure and axis\n    fig, ax = plt.subplots(dpi=150, figsize=(2.5, 5))\n    # Create boxplots\n    positions = range(1, len(methods_order) + 1)\n    ax.boxplot(scores_ordered, positions=positions)\n    fig_fontsize = 12\n    # Set the ticks and labels\n    method_labels = [\"IO\", \"CoT\", \"ToT\", \"ToT2\", \"GoT\"]\n    plt.yticks(fontsize=fig_fontsize)\n    ax.set_xticks(range(1, len(methods_order) + 1))\n    ax.set_xticks(range(1, len(methods_order) + 1))\n    ax.set_xticklabels(method_labels, fontsize=fig_fontsize)\n    y_upper = length\n    range_increase = 1\n    if display_solved:\n        if length < 48:\n            range_increase = 2\n        elif length < 96:\n            range_increase = 4\n        else:\n            range_increase = 8\n    ax.set_ylim(y_lower, y_upper + range_increase)\n    ax1_yticks = range(\n        y_lower, y_upper + 1, 2 if length < 48 else (4 if length < 96 else 8)"
        },
        {
            "comment": "Setting the y-tick positions and labels for ax2, setting the y-label for ax2 if display_right_ylabel is True, setting the title of the plot to length elements, setting the lower limit of the y-axis for ax2 if cost_upper > 0, adjusting the y-ticks' values for ax2 based on the number of ticks and the upper cost limit, and finally adding annotations for solved methods.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/sorting/plot.py\":131-162",
            "content": "    )\n    ax.set_yticks(ax1_yticks)\n    if display_left_ylabel:\n        ax.set_ylabel(f\"#incorrectly sorted elements; the lower the better\")\n    ax.set_title(f\"{length} elements\")\n    ax2 = ax.twinx()\n    ax2.bar(positions, total_costs, alpha=0.5, color=\"blue\", label=\"Total Cost ($)\")\n    ax2.yaxis.set_tick_params(colors=\"#1919ff\", labelsize=fig_fontsize)\n    if cost_upper > 0:\n        ax2.set_ylim(0, cost_upper)\n        number_of_ticks = len(ax.get_yticks())\n        tick_interval = cost_upper / (number_of_ticks)\n        ax2_ticks = [tick_interval * i for i in range(number_of_ticks)]\n        # Set custom tick positions for ax2\n        ax2.set_yticks(ax2_ticks)\n    if display_right_ylabel:\n        ax2.set_ylabel(\n            \"Total Cost ($); the lower the better\",\n            color=\"#1919ff\",\n            fontsize=fig_fontsize,\n        )\n    if display_solved:\n        annotation_height = y_upper + annotation_offset\n        count = 1\n        for method in methods_order:\n            if method not in results:\n                continue"
        },
        {
            "comment": "The code plots sorting algorithm performance data and displays the solved count for each method. It saves the plot as a PDF with the model name and length appended to its filename. The function is then called again with specific parameters, including GPT-3.5 as the model.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/sorting/plot.py\":163-185",
            "content": "            solved = results[method][\"solved\"]\n            ax.text(\n                count,\n                annotation_height,\n                f\"{solved}\",\n                ha=\"center\",\n                va=\"bottom\",\n                fontsize=fig_fontsize,\n            )\n            count += 1\n    model = model.replace(\".\", \"\").replace(\"-\", \"\").lower()\n    fig.savefig(f\"sorting_{model}_{length}.pdf\", bbox_inches=\"tight\")\nplot_results(\n    get_plotting_data(\"results/\"),\n    length=32,\n    display_solved=True,\n    model=\"GPT-3.5\",\n    display_left_ylabel=True,\n    display_right_ylabel=True,\n)"
        }
    ]
}