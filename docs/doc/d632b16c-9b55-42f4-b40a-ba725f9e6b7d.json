{
    "summary": "The code manages the execution flow of a graph's operations using language models and classes for processing, serialization, and debugging, resulting in an organized list written to a JSON file.",
    "details": [
        {
            "comment": "This code defines a Controller class to manage the execution flow of the Graph of Operations, utilizing language models, graph operations, prompting, and parsing. The Controller is initialized with an AbstractLanguageModel, GraphOfOperations, Prompter, Parser, and problem parameters.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/graph_of_thoughts/controller/controller.py\":0-34",
            "content": "# Copyright (c) 2023 ETH Zurich.\n#                    All rights reserved.\n#\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n#\n# main author: Nils Blach\nimport json\nimport logging\nfrom typing import List\nfrom graph_of_thoughts.language_models import AbstractLanguageModel\nfrom graph_of_thoughts.operations import GraphOfOperations, Thought\nfrom graph_of_thoughts.prompter import Prompter\nfrom graph_of_thoughts.parser import Parser\nclass Controller:\n    \"\"\"\n    Controller class to manage the execution flow of the Graph of Operations,\n    generating the Graph Reasoning State.\n    This involves language models, graph operations, prompting, and parsing.\n    \"\"\"\n    def __init__(\n        self,\n        lm: AbstractLanguageModel,\n        graph: GraphOfOperations,\n        prompter: Prompter,\n        parser: Parser,\n        problem_parameters: dict,\n    ) -> None:\n        \"\"\"\n        Initialize the Controller instance with the language model,\n        operations graph, prompter, parser, and problem parameters."
        },
        {
            "comment": "This function initializes a controller object with provided language model, graph of operations, prompter, parser, and problem parameters. It also sets the run_executed flag to False. The run method executes the operations from the Graph of Operations based on their readiness, ensuring the program is in a valid state before execution.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/graph_of_thoughts/controller/controller.py\":36-59",
            "content": "        :param lm: An instance of the AbstractLanguageModel.\n        :type lm: AbstractLanguageModel\n        :param graph: The Graph of Operations to be executed.\n        :type graph: OperationsGraph\n        :param prompter: An instance of the Prompter class, used to generate prompts.\n        :type prompter: Prompter\n        :param parser: An instance of the Parser class, used to parse responses.\n        :type parser: Parser\n        :param problem_parameters: Initial parameters/state of the problem.\n        :type problem_parameters: dict\n        \"\"\"\n        self.logger = logging.getLogger(self.__class__.__module__)\n        self.lm = lm\n        self.graph = graph\n        self.prompter = prompter\n        self.parser = parser\n        self.problem_parameters = problem_parameters\n        self.run_executed = False\n    def run(self) -> None:\n        \"\"\"\n        Run the controller and execute the operations from the Graph of\n        Operations based on their readiness.\n        Ensures the program is in a valid state before execution."
        },
        {
            "comment": "This code snippet is checking the validity of the program state and executing operations in a queue. It raises AssertionError if the Graph of Operations has no roots or if a successor operation is not found in the graph. The code logs debug messages for state checks, information messages for executed operations, and asserts to ensure proper execution order.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/graph_of_thoughts/controller/controller.py\":60-81",
            "content": "        :raises AssertionError: If the Graph of Operation has no roots.\n        :raises AssertionError: If the successor of an operation is not in the Graph of Operations.\n        \"\"\"\n        self.logger.debug(\"Checking that the program is in a valid state\")\n        assert self.graph.roots is not None, \"The operations graph has no root\"\n        self.logger.debug(\"The program is in a valid state\")\n        execution_queue = [\n            operation\n            for operation in self.graph.operations\n            if operation.can_be_executed()\n        ]\n        while len(execution_queue) > 0:\n            current_operation = execution_queue.pop(0)\n            self.logger.info(\"Executing operation %s\", current_operation.operation_type)\n            current_operation.execute(\n                self.lm, self.prompter, self.parser, **self.problem_parameters\n            )\n            self.logger.info(\"Operation %s executed\", current_operation.operation_type)\n            for operation in current_operation.successors:\n                assert ("
        },
        {
            "comment": "Code snippet defines a class with methods to execute operations in a graph, retrieve final thoughts after execution, and serialize the graph state and results. The `run` method executes operations in the graph, checks if operation is in graph's operations, appends executable operations to an execution queue, logs information when all operations are executed, and sets `run_executed` flag to True. `get_final_thoughts` method retrieves final thoughts after execution of all operations by iterating through graph's leaves and getting thoughts from each operation. It raises AssertionError if the run method has not been executed yet. `output_graph` method serializes state and results of operations graph to a JSON file at specified path.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/graph_of_thoughts/controller/controller.py\":82-105",
            "content": "                    operation in self.graph.operations\n                ), \"The successor of an operation is not in the operations graph\"\n                if operation.can_be_executed():\n                    execution_queue.append(operation)\n        self.logger.info(\"All operations executed\")\n        self.run_executed = True\n    def get_final_thoughts(self) -> List[List[Thought]]:\n        \"\"\"\n        Retrieve the final thoughts after all operations have been executed.\n        :return: List of thoughts for each operation in the graph's leaves.\n        :rtype: List[List[Thought]]\n        :raises AssertionError: If the `run` method hasn't been executed yet.\n        \"\"\"\n        assert self.run_executed, \"The run method has not been executed\"\n        return [operation.get_thoughts() for operation in self.graph.leaves]\n    def output_graph(self, path: str) -> None:\n        \"\"\"\n        Serialize the state and results of the operations graph to a JSON file.\n        :param path: The path to the output file.\n        :type path: str"
        },
        {
            "comment": "This code iterates through the operations in a graph, serializes each operation with its thoughts, and adds extra information if any thoughts have been scored, validated, or are invalid. This is used for generating an output list of serialized operations and associated data.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/graph_of_thoughts/controller/controller.py\":106-127",
            "content": "        \"\"\"\n        output = []\n        for operation in self.graph.operations:\n            operation_serialized = {\n                \"operation\": operation.operation_type.name,\n                \"thoughts\": [thought.state for thought in operation.get_thoughts()],\n            }\n            if any([thought.scored for thought in operation.get_thoughts()]):\n                operation_serialized[\"scored\"] = [\n                    thought.scored for thought in operation.get_thoughts()\n                ]\n                operation_serialized[\"scores\"] = [\n                    thought.score for thought in operation.get_thoughts()\n                ]\n            if any([thought.validated for thought in operation.get_thoughts()]):\n                operation_serialized[\"validated\"] = [\n                    thought.validated for thought in operation.get_thoughts()\n                ]\n                operation_serialized[\"validity\"] = [\n                    thought.valid for thought in operation.get_thoughts()\n                ]\n            if any("
        },
        {
            "comment": "This code iterates over the thoughts in each operation, compares them to ground truth, and determines if they were solved. The data is serialized and appended to a list, which is then written to a JSON file along with prompt, completion tokens, and cost information.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/graph_of_thoughts/controller/controller.py\":128-151",
            "content": "                [\n                    thought.compared_to_ground_truth\n                    for thought in operation.get_thoughts()\n                ]\n            ):\n                operation_serialized[\"compared_to_ground_truth\"] = [\n                    thought.compared_to_ground_truth\n                    for thought in operation.get_thoughts()\n                ]\n                operation_serialized[\"problem_solved\"] = [\n                    thought.solved for thought in operation.get_thoughts()\n                ]\n            output.append(operation_serialized)\n        output.append(\n            {\n                \"prompt_tokens\": self.lm.prompt_tokens,\n                \"completion_tokens\": self.lm.completion_tokens,\n                \"cost\": self.lm.cost,\n            }\n        )\n        with open(path, \"w\") as file:\n            file.write(json.dumps(output, indent=2))"
        }
    ]
}