{
    "summary": "Both scripts utilize Python to process data from JSON files, generate boxplots, and customize visualizations with various settings such as titles, colors, y-axis limits, cost thresholds, and display options.",
    "details": [
        {
            "comment": "This Python script reads data from a directory of JSON files, organizes it by folders, and stores the results in a dictionary. It uses the matplotlib library for plotting, but the code provided focuses on reading and organizing data, not plotting itself. The script is likely part of a larger program that utilizes this data for further analysis or visualization.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/paper/plots.py\":0-28",
            "content": "# Copyright (c) 2023 ETH Zurich.\n#                    All rights reserved.\n#\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n#\n# main author: Nils Blach\n# contributions: Robert Gerstenberger\nimport json\nimport os\nimport matplotlib.pyplot as plt\ndef get_complete_results(base_directory):\n    results_complete = {}\n    for folder_name in os.listdir(base_directory):\n        folder_path = os.path.join(base_directory, folder_name)\n        if os.path.isdir(folder_path):\n            results_complete[folder_name] = []\n            for file_name in os.listdir(folder_path):\n                if file_name.endswith(\".json\"):\n                    file_path = os.path.join(folder_path, file_name)\n                    with open(file_path, \"r\") as f:\n                        data = json.load(f)\n                        results_complete[folder_name].append(\n                            {\"key\": int(file_name.split(\".\")[0]), \"data\": data}\n                        )\n        for key in results_complete.keys():"
        },
        {
            "comment": "This code snippet sorts the results and then calculates final scores for different methods based on metrics like score, solution status, prompt and completion tokens, and cost.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/paper/plots.py\":29-57",
            "content": "            results_complete[key] = sorted(\n                results_complete[key], key=lambda x: x[\"key\"]\n            )\n    return results_complete\ndef get_final_scores(results_complete):\n    scores = {}\n    for method in results_complete.keys():\n        scores[method] = []\n        for result in results_complete[method]:\n            score = 100\n            solved = False\n            cost = 1\n            prompt_tokens = 0\n            completion_tokens = 0\n            for op in result[\"data\"]:\n                if \"operation\" in op and op[\"operation\"] == \"ground_truth_evaluator\":\n                    try:\n                        score = min(op[\"scores\"])\n                        solved = any(op[\"problem_solved\"])\n                    except:\n                        continue\n                if \"cost\" in op:\n                    cost = op[\"cost\"]\n                    prompt_tokens = op[\"prompt_tokens\"]\n                    completion_tokens = op[\"completion_tokens\"]\n            scores[method].append(\n                [result[\"key\"], score, solved, prompt_tokens, completion_tokens, cost]"
        },
        {
            "comment": "This function calculates the final scores for each method in the results_complete dictionary, considering factors like cost, prompt and completion tokens, and operation scores. It sorts the scores in ascending order before returning them.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/paper/plots.py\":58-86",
            "content": "            )\n        scores[method] = sorted(scores[method], key=lambda x: x[0])\n    return scores\ndef get_final_scores_doc_merge(results_complete):\n    scores = {}\n    for method in results_complete.keys():\n        scores[method] = []\n        for result in results_complete[method]:\n            score = 0\n            solved = False\n            cost = 1\n            prompt_tokens = 0\n            completion_tokens = 0\n            for op in reversed(result[\"data\"]):\n                if \"cost\" in op:\n                    cost = op[\"cost\"]\n                    prompt_tokens = op[\"prompt_tokens\"]\n                    completion_tokens = op[\"completion_tokens\"]\n                if \"operation\" in op and op[\"operation\"] == \"score\":\n                    try:\n                        score = max(op[\"scores\"])\n                        break\n                    except:\n                        continue\n            scores[method].append(\n                [result[\"key\"], score, solved, prompt_tokens, completion_tokens, cost]\n            )"
        },
        {
            "comment": "The code defines a function `get_plotting_data` that takes a base directory and a score method as input, returns plotting data for different methods by extracting scores, solved counts, and costs from the complete results. Another function, `plot_results`, is defined which takes various parameters such as name, results, methods order, etc., and plots the results based on the specified parameters. The code also includes checks to ensure that only valid methods are considered for plotting.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/paper/plots.py\":87-122",
            "content": "        scores[method] = sorted(scores[method], key=lambda x: x[0])\n    return scores\ndef get_plotting_data(base_directory, score_method):\n    results_complete = get_complete_results(base_directory)\n    scores = score_method(results_complete)\n    results_plotting = {\n        method: {\n            \"scores\": [x[1] for x in scores[method]],\n            \"solved\": sum([1 for x in scores[method] if x[2]]),\n            \"costs\": [x[5] for x in scores[method]],\n        }\n        for method in scores.keys()\n    }\n    return results_plotting\ndef plot_results(\n    name,\n    results,\n    methods_order=[\"io\", \"cot\", \"tot\", \"tot2\", \"tog\"],\n    methods_labels=[\"IO\", \"CoT\", \"ToT\", \"ToT2\", \"GoT\"],\n    model=\"GPT-3.5\",\n    length=32,\n    y_lower=0,\n    y_upper=16,\n    cost_upper=1.8,\n    display_solved=True,\n    annotation_offset=1,\n    display_left_ylabel=False,\n    display_right_ylabel=False,\n):\n    methods_order = [method for method in methods_order if method in results]\n    # Extract scores based on the order\n    if name == \"set_intersection\":"
        },
        {
            "comment": "The code is filtering scores and costs based on specific conditions for different tasks (e.g., sorting, keyword counting, document merging) and creating a figure with axes. For each task, it generates a list of filtered scores and total costs.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/paper/plots.py\":123-152",
            "content": "        scores_ordered = [\n            [min(score, length) for score in results[method][\"scores\"] if score != 1000]\n            for method in methods_order\n        ]\n    elif name == \"sorting\":\n        scores_ordered = [\n            [\n                min(score, length)\n                for score in results[method][\"scores\"]\n                if score != 100 and score != 300\n            ]\n            for method in methods_order\n        ]\n    elif name == \"keyword_counting\":\n        scores_ordered = [\n            [\n                score\n                for score in results[method][\"scores\"]\n                if score != 100 and score != 300\n            ]\n            for method in methods_order\n        ]\n    elif name == \"document_merging\":\n        scores_ordered = [\n            [score for score in results[method][\"scores\"]] for method in methods_order\n        ]\n    total_costs = [sum(results[method][\"costs\"]) for method in methods_order]\n    # Create figure and axis\n    if name == \"keyword_counting\" or name == \"document_merging\":"
        },
        {
            "comment": "Creates boxplots for sorted scores based on methods order, sets x-tick labels and y-limits according to the current name (method), adjusts y-ticks depending on length and displays left ylabel if needed.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/paper/plots.py\":153-183",
            "content": "        fig, ax = plt.subplots(dpi=150, figsize=(3.75, 5))\n    else:\n        fig, ax = plt.subplots(dpi=150, figsize=(2.5, 5))\n    # Create boxplots\n    positions = range(1, len(methods_order) + 1)\n    ax.boxplot(scores_ordered, positions=positions)\n    fig_fontsize = 12\n    # Set the ticks and labels\n    plt.yticks(fontsize=fig_fontsize)\n    ax.set_xticks(range(1, len(methods_order) + 1))\n    ax.set_xticks(range(1, len(methods_order) + 1))\n    if name == \"keyword_counting\":\n        ax.set_xticklabels(methods_labels, fontsize=10)\n    else:\n        ax.set_xticklabels(methods_labels, fontsize=fig_fontsize)\n    if name == \"document_merging\":\n        ax.set_ylim(y_lower, 12 if display_solved else 9.75)\n    else:\n        ax.set_ylim(y_lower, (y_upper + 2) if display_solved else y_upper + 1)\n    if name == \"sorting\" or name == \"set_intersection\":\n        ax1_yticks = range(\n            y_lower, y_upper + 1, 2 if length < 48 else (4 if length < 96 else 8)\n        )\n        ax.set_yticks(ax1_yticks)\n    if display_left_ylabel:"
        },
        {
            "comment": "If \"keyword_counting\", set ylabel as \"Number of errors; the lower the better\". If \"document_merging\", set ylabel as \"Score (out of 10); the higher the better\". Otherwise, set ylabel as \"#incorrect elements; the lower the better\". If \"sorting\" or \"set_intersection\", set title as length of elements. Add a blue bar chart for total cost using ax2. Set tick colors and ylim on ax2. Customize ytick positions for ax2 using provided interval.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/paper/plots.py\":184-211",
            "content": "        if name == \"keyword_counting\":\n            ax.set_ylabel(\n                f\"Number of errors; the lower the better\", fontsize=fig_fontsize\n            )\n        elif name == \"document_merging\":\n            ax.set_ylabel(\n                f\"Score (out of 10); the higher the better\", fontsize=fig_fontsize\n            )\n        else:\n            ax.set_ylabel(\n                f\"#incorrect elements; the lower the better\", fontsize=fig_fontsize\n            )\n    if name == \"sorting\" or name == \"set_intersection\":\n        ax.set_title(f\"{length} elements\")\n    ax2 = ax.twinx()\n    ax2.bar(positions, total_costs, alpha=0.5, color=\"blue\", label=\"Total Cost ($)\")\n    ax2.yaxis.set_tick_params(colors=\"#1919ff\", labelsize=fig_fontsize)\n    ax2.set_ylim(0, cost_upper)\n    number_of_ticks = len(ax.get_yticks())\n    tick_interval = cost_upper / (number_of_ticks)\n    ax2_ticks = [tick_interval * i for i in range(number_of_ticks)]\n    # Set custom tick positions for ax2\n    ax2.set_yticks(ax2_ticks)\n    if display_right_ylabel:"
        },
        {
            "comment": "Setting the y-label for a plot, displaying the number of solved methods, and saving the figure with appropriate filename based on the method name and model.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/paper/plots.py\":212-245",
            "content": "        ax2.set_ylabel(\n            \"Total Cost ($); the lower the better\",\n            color=\"#1919ff\",\n            fontsize=fig_fontsize,\n        )\n    if display_solved:\n        annotation_height = y_upper + annotation_offset\n        count = 1\n        for method in methods_order:\n            if method not in results:\n                continue\n            solved = results[method][\"solved\"]\n            ax.text(\n                count,\n                annotation_height,\n                f\"{solved}\",\n                ha=\"center\",\n                va=\"bottom\",\n                fontsize=fig_fontsize,\n            )\n            count += 1\n    model = model.replace(\".\", \"\").replace(\"-\", \"\").lower()\n    if name == \"keyword_counting\" or name == \"document_merging\":\n        fig.savefig(f\"{name}_{model}.pdf\", bbox_inches=\"tight\")\n    else:\n        fig.savefig(f\"{name}_{model}_{length}.pdf\", bbox_inches=\"tight\")\nplot_results(\n    \"set_intersection\",\n    get_plotting_data(\"set_intersection_gpt35_032\", get_final_scores),\n    methods_order=[\"io\", \"cot\", \"tot\", \"tot2\", \"tog2\"],"
        },
        {
            "comment": "The code snippet is defining functions and parameters for plotting data from various models. It uses the 'plot_results' function with different arguments to visualize the results of operations such as set intersection and sorting. The plots have various settings like length, upper limit, cost, display options, etc. to customize the visual representation of the data.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/paper/plots.py\":246-288",
            "content": "    length=32,\n    y_upper=19,\n    cost_upper=2,\n    display_solved=True,\n    annotation_offset=0.5,\n    display_left_ylabel=True,\n    display_right_ylabel=True,\n)\nplot_results(\n    \"set_intersection\",\n    get_plotting_data(\"set_intersection_gpt35_064\", get_final_scores),\n    methods_order=[\"io\", \"cot\", \"tot\", \"tot2\", \"tog2\"],\n    length=64,\n    y_upper=32,\n    cost_upper=5.4,\n    display_solved=True,\n    annotation_offset=0.2,\n    display_left_ylabel=True,\n    display_right_ylabel=True,\n)\nplot_results(\n    \"set_intersection\",\n    get_plotting_data(\"set_intersection_gpt35_128\", get_final_scores),\n    methods_order=[\"io\", \"cot\", \"tot\", \"tot2\", \"tog2\"],\n    length=128,\n    y_upper=94,\n    cost_upper=12,\n    display_solved=True,\n    annotation_offset=-3,\n    display_left_ylabel=True,\n    display_right_ylabel=True,\n)\nplot_results(\n    \"sorting\",\n    get_plotting_data(\"sorting_gpt35_032\", get_final_scores),\n    length=32,\n    display_solved=False,\n    annotation_offset=0.5,\n    display_left_ylabel=True,\n    display_right_ylabel=True,"
        },
        {
            "comment": "Code snippet contains multiple function calls to plot results using different sets of data and parameters. It plots data for tasks \"sorting\" and \"keyword_counting\", and \"document_merging\". Each call specifies the task, data, methods order, labels, limits, display options, and other settings.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/paper/plots.py\":289-329",
            "content": ")\nplot_results(\n    \"sorting\",\n    get_plotting_data(\"sorting_gpt35_064\", get_final_scores),\n    length=64,\n    y_upper=64,\n    cost_upper=5.1,\n    display_solved=False,\n    display_left_ylabel=True,\n    display_right_ylabel=True,\n)\nplot_results(\n    \"sorting\",\n    get_plotting_data(\"sorting_gpt35_128\", get_final_scores),\n    length=128,\n    y_upper=128,\n    cost_upper=17,\n    display_solved=False,\n    display_left_ylabel=True,\n    display_right_ylabel=True,\n)\nplot_results(\n    \"keyword_counting\",\n    get_plotting_data(\"keyword_counting_gpt35\", get_final_scores),\n    methods_order=[\"io\", \"cot\", \"tot\", \"tot2\", \"gsp4\", \"gsp8\", \"gspx\"],\n    methods_labels=[\"IO\", \"CoT\", \"ToT\", \"ToT2\", \"GoT4\", \"GoT8\", \"GoTx\"],\n    y_upper=35,\n    cost_upper=9,\n    display_solved=True,\n    annotation_offset=-0.3,\n    display_left_ylabel=True,\n    display_right_ylabel=True,\n)\nplot_results(\n    \"document_merging\",\n    get_plotting_data(\"document_merging_gpt35_16k\", get_final_scores_doc_merge),\n    methods_order=[\"io\", \"cot\", \"tot\", \"gsp\", \"gsp2\"],"
        },
        {
            "comment": "Parameters for plotting methods labels, upper limit of y-axis, cost threshold, and display options.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/paper/plots.py\":330-336",
            "content": "    methods_labels=[\"IO\", \"CoT\", \"ToT\", \"GoT\", \"GoT2\"],\n    y_upper=10,\n    cost_upper=15,\n    display_solved=False,\n    display_left_ylabel=True,\n    display_right_ylabel=True,\n)"
        }
    ]
}