{
    "summary": "The code imports libraries, defines a get_complete_results() function, reads JSON data and stores it in a dictionary, sorts the keys, retrieves final scores for each method using results_complete dictionary, and includes functions to retrieve plotting data and plot boxplots for scores with total cost bar plots on a secondary y-axis. It also sets custom y-axis positions and labels for plotting the solved status of various methods, saving it as a PDF, and generates data from given results while initializing an instance of the DocMerge class with a cost_upper limit of 15.",
    "details": [
        {
            "comment": "The code imports necessary libraries, defines a function get_complete_results(), and reads data from JSON files in specified directories. It collects this information into a dictionary, sorts the keys, and returns the complete results for further processing.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/doc_merge/plot.py\":0-28",
            "content": "# Copyright (c) 2023 ETH Zurich.\n#                    All rights reserved.\n#\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n#\n# main author: Nils Blach\nimport json\nimport os\nimport matplotlib.pyplot as plt\ndef get_complete_results(base_directory):\n    results_complete = {}\n    for folder_name in os.listdir(base_directory):\n        folder_path = os.path.join(base_directory, folder_name)\n        if os.path.isdir(folder_path):\n            results_complete[folder_name] = []\n            for file_name in os.listdir(folder_path):\n                if file_name.endswith(\".json\"):\n                    file_path = os.path.join(folder_path, file_name)\n                    with open(file_path, \"r\") as f:\n                        data = json.load(f)\n                        results_complete[folder_name].append(\n                            {\"key\": int(file_name.split(\".\")[0]), \"data\": data}\n                        )\n        for key in results_complete.keys():\n            results_complete[key] = sorted("
        },
        {
            "comment": "This code retrieves and sorts final scores for each method in the results_complete dictionary. It loops through each method, then through each result for that method, calculating the score, solved status, prompt/completion tokens, and cost from the reversed data list. Finally, it appends these values to the corresponding method's scores list, then sorts those scores by key.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/doc_merge/plot.py\":29-58",
            "content": "                results_complete[key], key=lambda x: x[\"key\"]\n            )\n    return results_complete\ndef get_final_scores(results_complete):\n    scores = {}\n    for method in results_complete.keys():\n        scores[method] = []\n        for result in results_complete[method]:\n            score = 0\n            solved = False\n            cost = 1\n            prompt_tokens = 0\n            completion_tokens = 0\n            for op in reversed(result[\"data\"]):\n                if \"cost\" in op:\n                    cost = op[\"cost\"]\n                    prompt_tokens = op[\"prompt_tokens\"]\n                    completion_tokens = op[\"completion_tokens\"]\n                if \"operation\" in op and op[\"operation\"] == \"score\":\n                    try:\n                        score = max(op[\"scores\"])\n                        break\n                    except:\n                        continue\n            scores[method].append(\n                [result[\"key\"], score, solved, prompt_tokens, completion_tokens, cost]\n            )\n        scores[method] = sorted(scores[method], key=lambda x: x[0])"
        },
        {
            "comment": "Function get_plotting_data returns a dictionary of plotting data for different methods, which includes scores, number of solved problems, and costs. Function plot_results plots the results using given parameters like methods order, model, number of nodes, y-axis limits, cost upper limit, etc. The function first ensures that the specified methods are in the result dictionary and then extracts ordered scores and total costs for each method from the results dictionary.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/doc_merge/plot.py\":59-95",
            "content": "    return scores\ndef get_plotting_data(base_directory):\n    results_complete = get_complete_results(base_directory)\n    scores = get_final_scores(results_complete)\n    results_plotting = {\n        method: {\n            \"scores\": [x[1] for x in scores[method]],\n            \"solved\": sum([1 for x in scores[method] if x[2]]),\n            \"costs\": [x[5] for x in scores[method]],\n        }\n        for method in scores.keys()\n    }\n    return results_plotting\ndef plot_results(\n    results,\n    methods_order=[\"io\", \"cot\", \"tot\", \"got\", \"got2\"],\n    model=\"GPT-3.5\",\n    num_ndas=4,\n    y_lower=0,\n    y_upper=10,\n    cost_upper=1.8,\n    display_solved=True,\n    annotation_offset=1,\n    display_left_ylabel=False,\n    display_right_ylabel=False,\n):\n    methods_order = [method for method in methods_order if method in results]\n    scores_ordered = [\n        [score for score in results[method][\"scores\"]] for method in methods_order\n    ]\n    total_costs = [sum(results[method][\"costs\"]) for method in methods_order]\n    # Create figure and axis"
        },
        {
            "comment": "Creates a boxplot for scores, sets ticks and labels for x-axis, adjusts y-limits, adds a blue bar plot with total costs on the right y-axis, and sets corresponding tick colors and limits.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/doc_merge/plot.py\":96-131",
            "content": "    fig, ax = plt.subplots(dpi=150, figsize=(3.75, 5))\n    # Create boxplots\n    positions = range(1, len(methods_order) + 1)\n    ax.boxplot(scores_ordered, positions=positions)\n    fig_fontsize = 12\n    # Set the ticks and labels\n    methods_labels = [\"IO\", \"CoT\", \"ToT\", \"GoT\", \"GoT2\"]\n    ax.set_xticks(range(1, len(methods_order) + 1))\n    ax.set_xticks(range(1, len(methods_order) + 1))\n    ax.set_xticklabels(methods_labels)\n    # ax.set_xlabel(\"Approach\")\n    ax.set_ylim(y_lower, 12 if display_solved else 9.75)\n    plt.yticks(fontsize=fig_fontsize)\n    if display_left_ylabel:\n        ax.set_ylabel(\n            f\"Score (out of 10); the higher the better\", fontsize=fig_fontsize\n        )\n    # ax.set_title(f\"Document Merging\")\n    ax2 = ax.twinx()\n    ax2.bar(\n        positions,\n        total_costs,\n        alpha=0.5,\n        color=\"blue\",\n        label=\"Total Cost ($); the lower the better\",\n    )\n    ax2.yaxis.set_tick_params(colors=\"#1919ff\", labelsize=fig_fontsize)\n    ax2.set_ylim(0, cost_upper)\n    number_of_ticks = len(ax.get_yticks())"
        },
        {
            "comment": "This code is setting custom tick positions and labels for the y-axis of a plot, displaying the solved status of various methods, saving the plot as a PDF, and generating plotting data from given results.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/doc_merge/plot.py\":132-167",
            "content": "    tick_interval = cost_upper / (number_of_ticks)\n    ax2_ticks = [tick_interval * i for i in range(number_of_ticks)]\n    # Set custom tick positions for ax2\n    ax2.set_yticks(ax2_ticks)\n    if display_right_ylabel:\n        ax2.set_ylabel(\n            \"Total Cost ($); the lower the better\",\n            color=\"#1919ff\",\n            fontsize=fig_fontsize,\n        )\n    if display_solved:\n        annotation_height = y_upper + annotation_offset\n        count = 1\n        for method in methods_order:\n            if method not in results:\n                continue\n            solved = results[method][\"solved\"]\n            ax.text(\n                count, annotation_height, f\"Solved: {solved}\", ha=\"center\", va=\"bottom\"\n            )\n            count += 1\n    model = model.replace(\".\", \"\").replace(\"-\", \"\").lower()\n    fig.savefig(f\"doc_merge_{model}_{num_ndas}.pdf\", bbox_inches=\"tight\")\nplot_results(\n    get_plotting_data(\"results/\"),\n    num_ndas=4,\n    display_solved=False,\n    model=\"GPT-3.5\",\n    y_upper=10,\n    display_left_ylabel=True,"
        },
        {
            "comment": "This code snippet is initializing a function, specifically an instance of the class \"DocMerge\", with the parameter 'cost_upper' set to 15. The purpose of this function might be to perform document merging or some similar operation with a specified upper cost limit.",
            "location": "\"/media/root/Toshiba XG3/works/graph-of-thoughts/docs/src/examples/doc_merge/plot.py\":168-169",
            "content": "    cost_upper=15,\n)"
        }
    ]
}